<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cover Generator</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="images/favicon-inverted.png">
    <link rel="shortcut icon" type="image/png" href="images/favicon-inverted.png">
    <link rel="apple-touch-icon" href="images/favicon-inverted.png">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://sinelnikov.name/cover-generator/">
    <meta property="og:title" content="Cover Generator">
    <meta property="og:description" content="Create beautiful social media covers and blog headers with Harvard Business School inspired patterns">
    <meta property="og:image" content="https://sinelnikov.name/cover-generator/images/open-graph.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://sinelnikov.name/cover-generator/">
    <meta property="twitter:title" content="Cover Generator">
    <meta property="twitter:description" content="Create beautiful social media covers and blog headers with Harvard Business School inspired patterns">
    <meta property="twitter:image" content="https://sinelnikov.name/cover-generator/images/open-graph.png">

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y8EFWM0GW9"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-Y8EFWM0GW9');
    </script>

    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            margin: 0;
            background-color: #f0f0f0;
        }

        .container {
            display: flex;
            flex-direction: row;
            min-height: 100vh;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 14px;
            min-width: 180px;
            padding: 14px 12px 14px 12px;
            background-color: white;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            box-sizing: border-box;
            z-index: 1;
            height: auto;
        }

        .canvas-area {
            flex: 1 1 0;
            min-width: 0;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            position: relative;
            padding: 0;
            background: none;
        }

        .canvas-area-inner {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 0 0 auto;
            padding-top: 50px;
            width: 100%;
            min-width: 0;
            min-height: 0;
            margin: 0;
        }

        .canvas-container {
            position: relative;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            border-radius: 4px;
            min-width: 0;
            margin-bottom: 24px;
            max-width: 100%;
            box-sizing: border-box;
        }

        #coverCanvas {
            display: block;
        }

        .section {
            margin-bottom: 10px;
        }

        .title {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
        }

        .title img {
            height: 1.56em;
            width: auto;
        }

        label {
            margin-bottom: 8px;
            font-size: 0.9em;
            font-weight: bold;
            color: #333;
            display: block;
        }

        .color-picker {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 2px;
            width: 160px;
            background-color: white;
            padding: 2px;
            border-radius: 6px;
        }

        .color-button {
            width: 100%;
            height: 20px;
            border: 1px solid transparent;
            cursor: pointer;
            transition: all 0.15s;
            position: relative;
            padding: 0;
            box-sizing: border-box;
            border-radius: 0;
        }

        .color-button:first-child {
            border-top-left-radius: 0;
        }

        .color-button:nth-child(4) {
            border-top-right-radius: 0;
        }

        .color-button:nth-last-child(4) {
            border-bottom-left-radius: 0;
        }

        .color-button:last-child {
            border-bottom-right-radius: 0;
        }

        .color-button.selected {
            outline: 2px solid #000;
            border: 2px solid white;
        }

        .color-button.pattern-selected {
            outline: 2px solid #000;
            border: 2px solid white;
        }

        .color-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 4px 8px;
            background: rgba(0,0,0,0.8);
            color: white;
            border-radius: 4px;
            font-size: 0.8em;
            white-space: nowrap;
            display: none;
            pointer-events: none;
            z-index: 1000;
        }

        .color-button:hover .color-tooltip {
            display: block;
        }

        /* Remove color mode toggle styles */
        .color-mode-toggle {
            display: none;
        }
        
        .color-mode-button {
            display: none;
        }

        /* Color definitions */
        .color-harvard-crimson { background-color: #A41034; }
        .color-red-2 { background-color: #E80538; }
        .color-red-3 { background-color: #ED5541; }
        .color-red-4 { background-color: #E0B2A7; }
        
        .color-orange-1 { background-color: #AE6429; }
        .color-orange-2 { background-color: #E87D1E; }
        .color-orange-3 { background-color: #EA9B20; }
        .color-orange-4 { background-color: #F7C76B; }
        
        .color-yellow-1 { background-color: #C29D00; }
        .color-yellow-2 { background-color: #EBCD00; }
        .color-yellow-3 { background-color: #F3E44D; }
        .color-yellow-4 { background-color: #F4EF6B; }
        
        .color-green-1 { background-color: #026833; }
        .color-green-2 { background-color: #52A52E; }
        .color-green-3 { background-color: #9EC44D; }
        .color-green-4 { background-color: #B3D56A; }
        
        .color-teal-1 { background-color: #006085; }
        .color-teal-2 { background-color: #00979D; }
        .color-teal-3 { background-color: #56BAB3; }
        .color-teal-4 { background-color: #9BD6C4; }
        
        .color-blue-1 { background-color: #3B2883; }
        .color-blue-2 { background-color: #6578B4; }
        .color-blue-3 { background-color: #7FA4D1; }
        .color-blue-4 { background-color: #AAC8EB; }
        
        .color-purple-1 { background-color: #57116A; }
        .color-purple-2 { background-color: #80408D; }
        .color-purple-3 { background-color: #9B7FAF; }
        .color-purple-4 { background-color: #C6B2D1; }
        
        .color-magenta-1 { background-color: #78244C; }
        .color-magenta-2 { background-color: #C9006B; }
        .color-magenta-3 { background-color: #D86199; }
        .color-magenta-4 { background-color: #E599BA; }
        
        .color-black { background-color: #000000; }
        .color-gray-2 { background-color: #68666F; }
        .color-gray-3 { background-color: #A3A0A2; }
        .color-gray-4 { background-color: #D5D0CA; }

        .pattern-picker {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            width: 100%;
            background: none;
            padding: 20px 0 0 20px;
            border-radius: 0;
            margin-bottom: 18px;
            box-sizing: border-box;
            justify-content: flex-start;
        }

        .pattern-button {
            width: 80px;
            height: 80px;
            max-width: 80px;
            max-height: 80px;
            aspect-ratio: 1/1;
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            padding: 0;
        }

        .pattern-preview-img {
            width: 80%;
            height: 80%;
            object-fit: cover;
            display: block;
        }

        .pattern-button:hover {
            background: #ececec;
            transform: scale(1.08);
            box-shadow: 0 2px 8px rgba(0,0,0,0.10);
            z-index: 2;
        }

        .pattern-button.selected {
            background: #d0d0d0;
            border: 2px solid #666;
        }

        /* Remove unused styles */
        .pattern-preview,
        .pattern-name,
        .section-header,
        .section-content,
        .collapse-icon {
            display: none;
        }

        .size-picker {
            display: block;
            margin-top: 4px;
            width: 160px;
        }

        .size-select {
            width: 100%;
            padding: 8px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background: #f8f8f8;
            font-size: 0.9em;
            color: #333;
            cursor: pointer;
            transition: all 0.2s;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23333%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 8px;
            padding-right: 24px;
        }

        .size-select:hover {
            background-color: #f0f0f0;
            border-color: #d0d0d0;
        }

        .size-select:focus {
            outline: none;
            border-color: #007AFF;
            box-shadow: 0 0 0 2px rgba(0,122,255,0.2);
        }

        .scale-control {
            margin: 27px 0 18px 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .slider-row {
            display: flex;
            flex-direction: row;
            align-items: center;
            width: 100%;
            max-width: 384px;
            gap: 8px;
            margin-bottom: 8px;
        }
        .scale-label-min, .scale-label-max {
            /* width and flex removed for min/max labels, only .scale-label-min is used now */
        }
        .scale-label-min {
            margin-right: 8px;
            text-align: left;
            font-size: 0.9em;
            font-weight: bold;
            color: #333;
            display: inline;
            margin-bottom: 0;
            align-self: center;
        }
        .scale-label-max {
            margin-left: 0;
            text-align: left;
        }
        .slider-container {
            position: relative;
            width: 100%;
            display: flex;
            align-items: center;
        }
        .scale-control input[type="range"] {
            flex: 1 1 auto;
            width: 100%;
            margin: 0;
            -webkit-appearance: none;
            background: transparent;
            height: 32px;
            border-radius: 2px;
            display: block;
        }
        .scale-control input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: linear-gradient(to bottom, #ccc 0%, #ccc 100%);
            border-radius: 2px;
            border: none;
        }
        .scale-control input[type="range"]::-moz-range-track {
            width: 100%;
            height: 4px;
            background: linear-gradient(to bottom, #ccc 0%, #ccc 100%);
            border-radius: 2px;
            border: none;
        }
        .scale-control input[type="range"]::-ms-fill-lower,
        .scale-control input[type="range"]::-ms-fill-upper {
            background: linear-gradient(to bottom, #ccc 0%, #ccc 100%);
            border-radius: 2px;
            border: none;
        }
        .scale-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            border: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #666666;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin-top: -7px;
        }
        .scale-control input[type="range"]::-moz-range-thumb {
            border: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #666666;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .scale-control input[type="range"]:focus {
            outline: none;
        }

        #saveBtn {
            display: block;
            margin: 32px auto 0 auto;
            padding: 14px 36px;
            background: #2766b6;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 40px;
        }

        #saveBtn:hover {
            background: #1d4e8c;
        }

        .group-title {
            font-size: 1.1em;
            font-weight: 500;
            color: #666;
            margin-top: 30px;
            margin-bottom: 15px;
            padding-left: 5px;
            border-left: 3px solid #007bff;
        }

        .section-header {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            cursor: pointer;
            user-select: none;
        }

        .section-header .collapse-icon {
            margin-left: auto;
            transition: transform 0.2s;
            font-size: 0.8em;
            color: #666;
        }

        .section-header.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .section-content {
            display: block;
            transition: all 0.2s;
            overflow: hidden;
            max-height: 1000px;
        }

        .section-content.collapsed {
            max-height: 0;
            margin: 0;
            padding: 0;
        }

        .copyright {
            width: 100%;
            text-align: center;
            font-size: 0.85em;
            color: #666;
            padding: 0;
            padding-bottom: 14px;
            margin: 0;
            pointer-events: none;
            margin-top: auto;
        }

        .copyright-left {
            width: auto;
            font-size: 0.85em;
            color: #666;
            padding: 0;
            text-align: left;
            margin-top: auto;
        }

        .copyright-left a {
            color: #666;
            text-decoration: none;
            border-bottom: 1px solid rgba(102, 102, 102, 0.3);
            transition: border-color 0.2s;
        }

        .copyright-left a:hover {
            color: #666;
            border-bottom-color: rgba(102, 102, 102, 0.6);
            text-decoration: none;
        }

        .copyright a {
            color: #666;
            text-decoration: none;
            border-bottom: 1px solid rgba(102, 102, 102, 0.3);
            transition: border-color 0.2s;
            pointer-events: auto;
        }

        .copyright a:hover {
            color: #666;
            border-bottom-color: rgba(102, 102, 102, 0.6);
            text-decoration: none;
        }

        .pattern-group-tabs {
            display: flex;
            flex-direction: column;
            gap: 0;
            margin-bottom: 12px;
            background: #e9e9e9;
            border-radius: 8px;
            border: 1px solid #ccc;
            overflow: hidden;
            width: 100%;
        }

        .pattern-group-button {
            width: 100%;
            padding: 10px 12px;
            background: #e9e9e9;
            border: none;
            border-bottom: 1px solid #ccc;
            cursor: pointer;
            transition: background 0.15s, color 0.15s;
            font-size: 0.95em;
            color: #666;
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-weight: 500;
        }

        .pattern-group-button:last-child {
            border-bottom: none;
        }

        .pattern-group-button.selected {
            background: #fff;
            color: #222;
            font-weight: 700;
        }

        .pattern-group-button:not(.selected):hover {
            background: #e0e0e0;
            color: #222;
        }

        .pattern-group-button:first-child {
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
        }

        .pattern-group-button:last-child {
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
        }

        .color-button:hover {
            z-index: 2;
            transform: scale(1.18);
            box-shadow: 0 2px 8px rgba(0,0,0,0.10);
        }

        /* Remove the pseudo-element */
        .scale-control::after {
            display: none;
        }

        .randomize-link-container {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 18px;
        }
        .randomize-link {
            background: none;
            border: none;
            color: #666;
            font-size: 1em;
            font-weight: 700;
            text-decoration: underline;
            text-decoration-color: rgba(102,102,102,0.25);
            text-underline-offset: 2px;
            padding: 0;
            transition: color 0.15s, text-decoration-color 0.15s;
            display: inline-block;
            cursor: pointer;
        }
        .randomize-link:hover {
            color: #333;
            text-decoration: underline;
            text-decoration-color: rgba(102,102,102,0.45);
        }
        .randomize-link-separator {
            color: #666;
            font-size: 1em;
            font-weight: 500;
        }

        .slider-container {
            position: relative;
            width: 100%;
        }
        .slider-value-label {
            position: absolute;
            top: -26px;
            left: 0;
            transform: translateX(-50%);
            background: #fff;
            color: #222;
            font-size: 1em;
            font-weight: 500;
            padding: 2px 8px;
            border-radius: 6px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.07);
            pointer-events: none;
            white-space: nowrap;
            z-index: 2;
        }

        .scale-caption {
            font-size: 0.98em;
            color: #444;
            margin-top: 2px;
            margin-left: 36px;
            text-align: left;
            width: 100%;
            max-width: 480px;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <div class="title">
               
                Cover Generator
            </div>
            <div class="section">
                <label>Canvas Size</label>
                <div class="size-picker">
                    <select class="size-select" id="sizeSelect">
                        <option value="851x315">Facebook Cover (851×315 px)</option>
                        <option value="1584x396">LinkedIn Cover (1584×396 px)</option>
                        <option value="1080x1080">Instagram Post (1080×1080 px)</option>
                        <option value="1080x1920">Instagram Story (1080×1920 px)</option>
                        <option value="1200x675">Twitter Post (1200×675 px)</option>
                        <option value="1280x720">YouTube Thumbnail (1280×720 px)</option>
                        <option value="733x307">Blog Cover (733×307 px)</option>
                        <option value="500x500">Square (500×500 px)</option>
                        <option value="custom">Custom...</option>
                    </select>
                </div>
            </div>
            <div class="section">
                <label>Background Color</label>
                <div class="color-picker" id="backgroundColorPicker"></div>
            </div>
            <div class="section">
                <label>Pattern Color</label>
                <div class="color-picker" id="patternColorPicker"></div>
            </div>
        </div>
        <div class="canvas-area">
            <div class="pattern-picker" id="patternPicker"></div>
            <div class="canvas-area-inner">
                <div class="randomize-link-container">
                    <a href="#" class="randomize-link">Randomize all</a>
                    <span class="randomize-link-separator">·</span>
                    <a href="#" class="randomize-link" id="randomizeColorsLink">Only colors</a>
                </div>
                <div class="canvas-container">
                    <svg id="coverCanvas" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 500">
                        <rect id="background" width="100%" height="100%" />
                        <defs>
                            <pattern id="architecturePattern" 
                                    patternUnits="userSpaceOnUse"
                                    patternTransform="translate(0,0)">
                                <g id="patternGroup" transform-origin="center">
                                    <image id="patternImage" 
                                           preserveAspectRatio="xMidYMid meet" />
                                </g>
                            </pattern>
                        </defs>
                        <rect id="patternOverlay" width="100%" height="100%" fill="url(#architecturePattern)" y="0" />
                    </svg>
                </div>
                <div class="scale-control">
                    <div class="slider-row" style="position: relative; width: 100%; max-width: 384px;">
                        <span class="scale-label-min" style="text-align: left; width: auto; flex: 0 0 auto;">Pattern scale:</span>
                        <div class="slider-container" style="position: relative; flex: 1 1 auto; width: 100%;">
                            <input type="range" id="patternScale" min="0.2" max="5" step="0.1" value="1" style="width: 100%;">
                            <span id="sliderValueLabel" class="slider-value-label">1.0×</span>
                        </div>
                    </div>
                </div>
                <button id="saveBtn">Save Image</button>
            </div>
            <div class="copyright">
                © <a href="https://sinelnikov.name">Ilya Sinelnikov</a>, 2025.      Patterns and color palette adapted from <a href="https://identity.hbs.edu/graphics/" target="_blank">Harvard Business School identity guidelines</a>
            </div>
        </div>
    </div>

    <div id="customSizeModal" style="display:none; position:fixed; z-index:10000; left:0; top:0; width:100vw; height:100vh; background:rgba(0,0,0,0.25); align-items:center; justify-content:center;">
        <div style="background:white; border-radius:8px; box-shadow:0 2px 16px rgba(0,0,0,0.15); padding:32px 24px; min-width:320px; max-width:90vw;">
            <h3 style="margin-top:0;">Custom Canvas Size</h3>
            <div style="margin-bottom:16px;">
                <label for="customWidth">Width (px):</label>
                <input id="customWidth" type="number" min="1" max="5000" value="800" style="width:80px; margin-left:8px;">
            </div>
            <div style="margin-bottom:24px;">
                <label for="customHeight">Height (px):</label>
                <input id="customHeight" type="number" min="1" max="5000" value="400" style="width:80px; margin-left:8px;">
            </div>
            <button id="customSizeOk" style="background:#007AFF; color:white; border:none; border-radius:4px; padding:8px 18px; font-weight:500; margin-right:8px;">OK</button>
            <button id="customSizeCancel" style="background:#eee; color:#333; border:none; border-radius:4px; padding:8px 18px;">Cancel</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const CANVAS_SIZE = 500;
            let currentBgColor;
            let currentPatternColor;
            let currentPatternGroup;
            let currentPattern;
            let canvasWidth = 733;
            let canvasHeight = 307;
            let currentColorMode = 'background';

            // Pattern group to folder and file naming mapping
            const PATTERN_GROUP_CONFIG = {
                'Architecture': {
                    folder: 'HBS-Architecture-Patterns',
                    file: n => `HBS_pattern_architecture_${n}.svg`,
                    name: n => `Architecture ${n}`,
                    maxPattern: 3  // Limit to only 3 patterns
                },
                'Fences': {
                    folder: 'HBS-Fences-Patterns',
                    file: n => `HBS_Fences_Patterns_${n}.svg`,
                    name: n => `Fences ${n}`
                },
                'Geometric': {
                    folder: 'HBS-Geometric-Patterns',
                    file: n => `HBS_pattern_geometric_${n}.svg`,
                    name: n => `Geometric ${n}`,
                    maxPattern: 3  // Limit to only 3 patterns
                },
                'Shields': {
                    folder: 'HBS-Shields-Patterns',
                    file: n => `HBS_pattern_shield_${n}.svg`,
                    name: n => `Shields ${n}`
                }
            };

            // Build a flat list of all patterns
            const ALL_PATTERNS = [];
            for (const group of Object.keys(PATTERN_GROUP_CONFIG)) {
                const maxPattern = PATTERN_GROUP_CONFIG[group].maxPattern || 4;
                for (let i = 1; i <= maxPattern; i++) {
                    ALL_PATTERNS.push({
                        group,
                        number: i,
                        name: PATTERN_GROUP_CONFIG[group].name(i),
                        folder: PATTERN_GROUP_CONFIG[group].folder,
                        file: PATTERN_GROUP_CONFIG[group].file(i)
                    });
                }
            }

            // Render all pattern buttons
            const patternPicker = document.getElementById('patternPicker');
            patternPicker.innerHTML = '';
            ALL_PATTERNS.forEach((pattern, idx) => {
                const btn = document.createElement('button');
                btn.className = 'pattern-button';
                btn.dataset.group = pattern.group;
                btn.dataset.pattern = pattern.number;
                btn.style.gridColumn = (idx % 2) + 1;
                // Tooltip
                const tooltip = document.createElement('span');
                tooltip.className = 'color-tooltip';
                tooltip.textContent = pattern.name;
                btn.appendChild(tooltip);
                // Image
                const img = document.createElement('img');
                img.className = 'pattern-preview-img';
                img.alt = pattern.name;
                // Load SVG preview as base64
                fetch(`patterns/${pattern.folder}/${pattern.file}`)
                    .then(r => r.text())
                    .then(svgText => {
                        // Zoom in 5x by adjusting the viewBox
                        const viewBoxMatch = svgText.match(/viewBox="([\d\.\s]+)"/);
                        if (viewBoxMatch) {
                            const [, viewBox] = viewBoxMatch;
                            const [x, y, w, h] = viewBox.split(/\s+/).map(Number);
                            const zoom = 5;
                            const newW = w / zoom;
                            const newH = h / zoom;
                            const newX = x + (w - newW) / 2;
                            const newY = y + (h - newH) / 2;
                            svgText = svgText.replace(/viewBox="[^"]+"/, `viewBox="${newX} ${newY} ${newW} ${newH}"`);
                        }
                        const svgBase64 = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgText)));
                        img.src = svgBase64;
                    })
                    .catch(() => { img.src = ''; });
                btn.appendChild(img);
                // Hover for tooltip
                btn.onmouseenter = () => { tooltip.style.display = 'block'; };
                btn.onmouseleave = () => { tooltip.style.display = 'none'; };
                // Click to select
                btn.onclick = () => {
                    document.querySelectorAll('.pattern-button').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    currentPatternGroup = pattern.group;
                    currentPattern = pattern.number;
                    updateCover();
                };
                patternPicker.appendChild(btn);
            });

            // DOM elements must be defined before calling update functions
            const pattern = document.getElementById('architecturePattern');
            const patternImage = document.getElementById('patternImage');
            const background = document.getElementById('background');
            const patternScaleInput = document.getElementById('patternScale');
            const scaleValueSpan = document.getElementById('scaleValue');
            const coverCanvas = document.getElementById('coverCanvas');
            const canvasContainer = document.querySelector('.canvas-container');

            // Store the current pattern's viewBox dimensions
            let currentPatternViewBox = { svgWidth: 2246.51, svgHeight: 1532.98 };

            // Initialize all controls
            setupColorPickers();
            setupSizePicker();

            // Initial update (now safe)
            updateColorPickerState();
            updateCanvasSize();
            updateCover();

            function updateCanvasSize() {
                // Update SVG viewBox
                coverCanvas.setAttribute('viewBox', `0 0 ${canvasWidth} ${canvasHeight}`);
                
                // Set maximum dimensions for display
                const maxDisplayWidth = 1200; // Increased from 800 to accommodate LinkedIn size
                const maxDisplayHeight = 600;
                
                // Calculate scale to fit within maximum dimensions while maintaining aspect ratio
                const widthScale = maxDisplayWidth / canvasWidth;
                const heightScale = maxDisplayHeight / canvasHeight;
                const scale = Math.min(widthScale, heightScale, 1); // Added 1 as maximum to prevent upscaling
                
                // Calculate final display dimensions
                const displayWidth = canvasWidth * scale;
                const displayHeight = canvasHeight * scale;
                
                // Update container size
                canvasContainer.style.width = `${displayWidth}px`;
                canvasContainer.style.height = `${displayHeight}px`;
                
                // Update background rectangle
                background.setAttribute('width', canvasWidth);
                background.setAttribute('height', canvasHeight);
                
                // Update pattern overlay
                document.getElementById('patternOverlay').setAttribute('width', canvasWidth);
                document.getElementById('patternOverlay').setAttribute('height', canvasHeight);
            }

            async function updateCover() {
                if (!currentPatternGroup || !currentPattern || !PATTERN_GROUP_CONFIG[currentPatternGroup]) {
                    console.warn('updateCover called with invalid group or pattern:', currentPatternGroup, currentPattern);
                    return;
                }
                background.setAttribute('fill', currentBgColor);
                try {
                    // Map group to folder and file
                    const config = PATTERN_GROUP_CONFIG[currentPatternGroup];
                    const folder = config.folder;
                    const file = config.file(currentPattern);
                    const response = await fetch(`patterns/${folder}/${file}`);
                    if (!response.ok) {
                        throw new Error(`Pattern file not found: patterns/${folder}/${file}`);
                    }
                    const svgText = await response.text();
                    // Extract viewBox dimensions from SVG
                    const viewBoxMatch = svgText.match(/viewBox="([\d\.\s]+)"/);
                    if (viewBoxMatch) {
                        const [, viewBox] = viewBoxMatch;
                        const [x, y, w, h] = viewBox.split(/\s+/).map(Number);
                        currentPatternViewBox = { svgWidth: w, svgHeight: h };
                    } else {
                        currentPatternViewBox = { svgWidth: 2246.51, svgHeight: 1532.98 };
                    }
                    // Create a temporary DOM element to parse and modify the SVG
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
                    // Add fill and stroke attributes to all path elements that don't have them
                    svgDoc.querySelectorAll('path').forEach(path => {
                        if (!path.hasAttribute('fill')) {
                            path.setAttribute('fill', 'none');
                        }
                        if (!path.hasAttribute('stroke')) {
                            path.setAttribute('stroke', currentPatternColor);
                        }
                    });
                    // Convert back to string
                    const serializer = new XMLSerializer();
                    let coloredSvg = serializer.serializeToString(svgDoc);
                    // Replace any remaining color attributes
                    coloredSvg = coloredSvg
                        .replace(/stroke: ?#[^;]*/g, `stroke: ${currentPatternColor}`)
                        .replace(/stroke="[^"]*"/g, `stroke="${currentPatternColor}"`)
                        .replace(/fill: ?#[^;]*/g, `fill: ${currentPatternColor}`)
                        .replace(/fill="[^"]*"/g, `fill="${currentPatternColor}"`);
                    const blob = new Blob([coloredSvg], { type: 'image/svg+xml' });
                    const url = URL.createObjectURL(blob);
                    // Update the pattern image
                    patternImage.setAttribute('href', url);
                    // Clean up the old URL if it exists
                    const oldUrl = patternImage.dataset.url;
                    if (oldUrl) {
                        URL.revokeObjectURL(oldUrl);
                    }
                    patternImage.dataset.url = url;
                    // Update pattern dimensions after loading new SVG
                    updatePatternDimensions();
                } catch (error) {
                    console.error('Error loading pattern:', error, 'Group:', currentPatternGroup, 'Pattern:', currentPattern);
                    alert('Error loading pattern. Please make sure the server is running and the pattern exists.\n' + error);
                    // Clear the pattern image if fetch fails
                    patternImage.removeAttribute('href');
                    if (patternImage.dataset.url) {
                        URL.revokeObjectURL(patternImage.dataset.url);
                        delete patternImage.dataset.url;
                    }
                }
            }

            function updatePatternDimensions() {
                const scale = parseFloat(patternScaleInput.value) || 1;
                // Use the dynamically extracted viewBox dimensions
                const { svgWidth, svgHeight } = currentPatternViewBox;
                const svgAspectRatio = svgWidth / svgHeight;
                // Calculate base dimensions to match canvas height at scale 1.0
                const baseHeight = canvasHeight;
                const baseWidth = baseHeight * svgAspectRatio;
                // Calculate scaled dimensions
                const scaledWidth = baseWidth * scale;
                const scaledHeight = baseHeight * scale;
                // Calculate offset to keep pattern centered
                const offsetX = (canvasWidth - scaledWidth) / 2;
                const offsetY = (canvasHeight - scaledHeight) / 2;
                // Update pattern attributes
                pattern.setAttribute('width', scaledWidth);
                pattern.setAttribute('height', scaledHeight);
                pattern.setAttribute('patternTransform', `translate(${offsetX},${offsetY})`);
                // Update image dimensions
                patternImage.setAttribute('width', scaledWidth);
                patternImage.setAttribute('height', scaledHeight);
            }

            // Attach slider event handler only after both slider and label exist
            function attachSliderHandler() {
                const slider = document.getElementById('patternScale');
                const label = document.getElementById('sliderValueLabel');
                if (!slider) {
                    setTimeout(attachSliderHandler, 50);
                    return;
                }
                slider.addEventListener('input', () => {
                    const scale = parseFloat(slider.value);
                    updatePatternDimensions();
                    // Always update the static label
                    if (typeof scaleValueSpan !== 'undefined' && scaleValueSpan) {
                        scaleValueSpan.textContent = scale.toFixed(1);
                    }
                    // Optionally update the dynamic label if it exists
                    if (label) {
                        // Calculate percent position
                        const min = parseFloat(slider.min);
                        const max = parseFloat(slider.max);
                        const val = parseFloat(slider.value);
                        const percent = (val - min) / (max - min);
                        // Get slider width
                        const sliderWidth = slider.offsetWidth;
                        // Calculate label position (centered above thumb, but 35% closer)
                        const thumbSize = 18; // matches CSS
                        const closer = 0.35; // 35% closer
                        const labelX = percent * (sliderWidth - thumbSize) * (1 - closer) + thumbSize / 2 + percent * (sliderWidth - thumbSize) * closer;
                        label.style.left = `${labelX}px`;
                        label.textContent = val.toFixed(1) + '×';
                    }
                });
                // Set initial label position and value
                if (label) {
                    const min = parseFloat(slider.min);
                    const max = parseFloat(slider.max);
                    const val = parseFloat(slider.value);
                    const percent = (val - min) / (max - min);
                    const sliderWidth = slider.offsetWidth;
                    const thumbSize = 18;
                    const closer = 0.35;
                    const labelX = percent * (sliderWidth - thumbSize) * (1 - closer) + thumbSize / 2 + percent * (sliderWidth - thumbSize) * closer;
                    label.style.left = `${labelX}px`;
                    label.textContent = val.toFixed(1) + '×';
                }
            }
            attachSliderHandler();

            function setupSizePicker() {
                const sizeSelect = document.getElementById('sizeSelect');
                const customSizeModal = document.getElementById('customSizeModal');
                const customWidthInput = document.getElementById('customWidth');
                const customHeightInput = document.getElementById('customHeight');
                const customOkBtn = document.getElementById('customSizeOk');
                const customCancelBtn = document.getElementById('customSizeCancel');

                sizeSelect.addEventListener('change', () => {
                    const [width, height] = sizeSelect.value.split('x').map(Number);
                    if (sizeSelect.value === 'custom') {
                        // Show modal
                        customSizeModal.style.display = 'flex';
                        // Set defaults to current size
                        customWidthInput.value = canvasWidth;
                        customHeightInput.value = canvasHeight;
                    } else {
                        canvasWidth = width;
                        canvasHeight = height;
                        updateCanvasSize();
                        updatePatternDimensions();
                    }
                });
                // Modal OK
                customOkBtn.addEventListener('click', () => {
                    const w = parseInt(customWidthInput.value, 10);
                    const h = parseInt(customHeightInput.value, 10);
                    if (w > 0 && h > 0) {
                        canvasWidth = w;
                        canvasHeight = h;
                        updateCanvasSize();
                        updatePatternDimensions();
                        // Set dropdown to custom
                        sizeSelect.value = 'custom';
                        customSizeModal.style.display = 'none';
                    }
                });
                // Modal Cancel
                customCancelBtn.addEventListener('click', () => {
                    customSizeModal.style.display = 'none';
                    // Reset dropdown to previous value
                    sizeSelect.selectedIndex = 0;
                });
                // Hide modal on outside click
                customSizeModal.addEventListener('click', (e) => {
                    if (e.target === customSizeModal) {
                        customSizeModal.style.display = 'none';
                        sizeSelect.selectedIndex = 0;
                    }
                });
            }

            function setupColorPickers() {
                // Create color buttons for both pickers
                const colorButtons = [
                    // Reds
                    { color: '#A41034', name: 'Harvard Crimson', class: 'color-harvard-crimson' },
                    { color: '#E80538', name: 'Red 2', class: 'color-red-2' },
                    { color: '#ED5541', name: 'Red 3', class: 'color-red-3' },
                    { color: '#E0B2A7', name: 'Red 4', class: 'color-red-4' },
                    
                    // Oranges
                    { color: '#AE6429', name: 'Orange 1', class: 'color-orange-1' },
                    { color: '#E87D1E', name: 'Orange 2', class: 'color-orange-2' },
                    { color: '#EA9B20', name: 'Orange 3', class: 'color-orange-3' },
                    { color: '#F7C76B', name: 'Orange 4', class: 'color-orange-4' },
                    
                    // Yellows
                    { color: '#C29D00', name: 'Yellow 1', class: 'color-yellow-1' },
                    { color: '#EBCD00', name: 'Yellow 2', class: 'color-yellow-2' },
                    { color: '#F3E44D', name: 'Yellow 3', class: 'color-yellow-3' },
                    { color: '#F4EF6B', name: 'Yellow 4', class: 'color-yellow-4' },
                    
                    // Greens
                    { color: '#026833', name: 'Green 1', class: 'color-green-1' },
                    { color: '#52A52E', name: 'Green 2', class: 'color-green-2' },
                    { color: '#9EC44D', name: 'Green 3', class: 'color-green-3' },
                    { color: '#B3D56A', name: 'Green 4', class: 'color-green-4' },
                    
                    // Teals
                    { color: '#006085', name: 'Teal 1', class: 'color-teal-1' },
                    { color: '#00979D', name: 'Teal 2', class: 'color-teal-2' },
                    { color: '#56BAB3', name: 'Teal 3', class: 'color-teal-3' },
                    { color: '#9BD6C4', name: 'Teal 4', class: 'color-teal-4' },
                    
                    // Blues
                    { color: '#3B2883', name: 'Blue 1', class: 'color-blue-1' },
                    { color: '#6578B4', name: 'Blue 2', class: 'color-blue-2' },
                    { color: '#7FA4D1', name: 'Blue 3', class: 'color-blue-3' },
                    { color: '#AAC8EB', name: 'Blue 4', class: 'color-blue-4' },
                    
                    // Purples
                    { color: '#57116A', name: 'Purple 1', class: 'color-purple-1' },
                    { color: '#80408D', name: 'Purple 2', class: 'color-purple-2' },
                    { color: '#9B7FAF', name: 'Purple 3', class: 'color-purple-3' },
                    { color: '#C6B2D1', name: 'Purple 4', class: 'color-purple-4' },
                    
                    // Magentas
                    { color: '#78244C', name: 'Magenta 1', class: 'color-magenta-1' },
                    { color: '#C9006B', name: 'Magenta 2', class: 'color-magenta-2' },
                    { color: '#D86199', name: 'Magenta 3', class: 'color-magenta-3' },
                    { color: '#E599BA', name: 'Magenta 4', class: 'color-magenta-4' },
                    
                    // Grays
                    { color: '#000000', name: 'Black', class: 'color-black' },
                    { color: '#68666F', name: 'Gray 2', class: 'color-gray-2' },
                    { color: '#A3A0A2', name: 'Gray 3', class: 'color-gray-3' },
                    { color: '#D5D0CA', name: 'Gray 4', class: 'color-gray-4' }
                ];

                // Create and populate both color pickers
                const bgPicker = document.getElementById('backgroundColorPicker');
                const patternPicker = document.getElementById('patternColorPicker');

                colorButtons.forEach(button => {
                    // Create button for background picker
                    const bgButton = document.createElement('div');
                    bgButton.className = `color-button ${button.class}`;
                    bgButton.dataset.color = button.color;
                    bgButton.innerHTML = `<div class="color-tooltip">${button.name}</div>`;
                    bgButton.addEventListener('click', () => {
                        currentBgColor = button.color;
                        updateColorPickerState();
                        updateCover();
                    });
                    bgPicker.appendChild(bgButton);

                    // Create button for pattern picker
                    const patternButton = document.createElement('div');
                    patternButton.className = `color-button ${button.class}`;
                    patternButton.dataset.color = button.color;
                    patternButton.innerHTML = `<div class="color-tooltip">${button.name}</div>`;
                    patternButton.addEventListener('click', () => {
                        currentPatternColor = button.color;
                        updateColorPickerState();
                        updateCover();
                    });
                    patternPicker.appendChild(patternButton);
                });
            }

            function updateColorPickerState() {
                // Update background color picker
                const bgButtons = document.querySelectorAll('#backgroundColorPicker .color-button');
                bgButtons.forEach(button => {
                    button.classList.toggle('selected', button.dataset.color === currentBgColor);
                });

                // Update pattern color picker
                const patternButtons = document.querySelectorAll('#patternColorPicker .color-button');
                patternButtons.forEach(button => {
                    button.classList.toggle('selected', button.dataset.color === currentPatternColor);
                });
            }

            async function convertImageToBase64(url, color) {
                // Map group to folder and file
                const config = PATTERN_GROUP_CONFIG[currentPatternGroup];
                const folder = config.folder;
                const file = config.file(currentPattern);
                const response = await fetch(`patterns/${folder}/${file}`);
                const svgText = await response.text();
                
                // Create a temporary DOM element to parse and modify the SVG
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
                
                // Add fill and stroke attributes to all path elements
                svgDoc.querySelectorAll('path').forEach(path => {
                    if (!path.hasAttribute('fill')) {
                        path.setAttribute('fill', 'none');
                    }
                    if (!path.hasAttribute('stroke')) {
                        path.setAttribute('stroke', color);
                    }
                });
                
                // Convert back to string and replace any remaining color attributes
                const serializer = new XMLSerializer();
                let coloredSvg = serializer.serializeToString(svgDoc);
                
                // Replace any remaining color attributes
                coloredSvg = coloredSvg
                    .replace(/stroke: ?#[^;]*/g, `stroke: ${color}`)
                    .replace(/stroke="[^"]*"/g, `stroke="${color}"`)
                    .replace(/fill: ?#[^;]*/g, `fill: ${color}`)
                    .replace(/fill="[^"]*"/g, `fill="${color}"`);
                
                // Convert to blob and then to base64
                const blob = new Blob([coloredSvg], { type: 'image/svg+xml' });
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            document.getElementById('saveBtn').addEventListener('click', async () => {
                try {
                    // Get the SVG element that's currently rendered
                    const svg = document.getElementById('coverCanvas');
                    
                    // Clone the SVG to preserve the exact state
                    const clonedSvg = svg.cloneNode(true);
                    
                    // Copy computed dimensions and viewBox
                    clonedSvg.setAttribute('width', canvasWidth);
                    clonedSvg.setAttribute('height', canvasHeight);
                    clonedSvg.setAttribute('viewBox', `0 0 ${canvasWidth} ${canvasHeight}`);
                    
                    // Ensure pattern is copied correctly
                    const originalPattern = svg.querySelector('#architecturePattern');
                    const clonedPattern = clonedSvg.querySelector('#architecturePattern');
                    
                    if (originalPattern && clonedPattern) {
                        // Copy all attributes
                        Array.from(originalPattern.attributes).forEach(attr => {
                            clonedPattern.setAttribute(attr.name, attr.value);
                        });
                        
                        // Handle pattern image
                        const originalImage = originalPattern.querySelector('image');
                        const clonedImage = clonedPattern.querySelector('image');
                        if (originalImage && clonedImage) {
                            // Get the current pattern URL
                            const config = PATTERN_GROUP_CONFIG[currentPatternGroup];
                            const folder = config.folder;
                            const file = config.file(currentPattern);
                            const patternUrl = `patterns/${folder}/${file}`;
                            
                            // Convert pattern to base64 with color
                            const base64Pattern = await convertImageToBase64(patternUrl, currentPatternColor);
                            clonedImage.setAttribute('href', base64Pattern);
                            
                            // Copy other attributes
                            Array.from(originalImage.attributes).forEach(attr => {
                                if (attr.name !== 'href') {
                                    clonedImage.setAttribute(attr.name, attr.value);
                                }
                            });
                        }
                    }
                    
                    // Create canvas with the exact dimensions
                    const canvas = document.createElement('canvas');
                    canvas.width = canvasWidth;
                    canvas.height = canvasHeight;
                    const ctx = canvas.getContext('2d');
                    
                    // Convert cloned SVG to data URL
                    const svgData = new XMLSerializer().serializeToString(clonedSvg);
                    const svgBlob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
                    const svgUrl = URL.createObjectURL(svgBlob);
                    
                    // Create a new promise to handle image loading
                    await new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => {
                            // Fill background first
                            ctx.fillStyle = currentBgColor;
                            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                            
                            // Draw the SVG
                            ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
                            
                            // Create and trigger download
                            const link = document.createElement('a');
                            link.download = `cover-${canvasWidth}x${canvasHeight}.png`;
                            link.href = canvas.toDataURL('image/png', 1.0);
                            link.click();
                            
                            // Track download event
                            gtag('event', 'image_download', {
                                'event_category': 'engagement',
                                'event_label': 'Image Download'
                            });
                            
                            // Cleanup
                            URL.revokeObjectURL(svgUrl);
                            resolve();
                        };
                        
                        img.onerror = (error) => {
                            console.error('Error loading SVG:', error);
                            URL.revokeObjectURL(svgUrl);
                            reject(new Error('Failed to load SVG'));
                        };
                        
                        img.src = svgUrl;
                    });
                } catch (error) {
                    console.error('Error saving image:', error);
                    alert('Error generating the image. Please try again.');
                }
            });

            // --- RANDOMIZE LINK FUNCTIONALITY ---
            async function randomizeCover() {
                // 1. Random pattern group
                const patternGroups = Object.keys(PATTERN_GROUP_CONFIG);
                const randomGroup = patternGroups[Math.floor(Math.random() * patternGroups.length)];
                currentPatternGroup = randomGroup;

                // 2. Random pattern (respect maxPattern for group)
                const maxPattern = PATTERN_GROUP_CONFIG[randomGroup].maxPattern || 4;
                const randomPattern = (Math.floor(Math.random() * maxPattern) + 1).toString();
                currentPattern = randomPattern;

                // Update pattern button UI
                document.querySelectorAll('.pattern-button').forEach(btn => {
                    btn.classList.toggle('selected', btn.dataset.group === randomGroup && btn.dataset.pattern === randomPattern);
                });

                // 3. Get all color values
                const colorButtons = Array.from(document.querySelectorAll('.color-button'));
                const colorValues = colorButtons.map(btn => btn.dataset.color);

                // 4. Random background color
                let bgColor = colorValues[Math.floor(Math.random() * colorValues.length)];

                // 5. Random pattern color (must not match bgColor)
                let patternColor;
                do {
                    patternColor = colorValues[Math.floor(Math.random() * colorValues.length)];
                } while (patternColor === bgColor && colorValues.length > 1);

                currentBgColor = bgColor;
                currentPatternColor = patternColor;

                // Update color picker UI
                updateColorPickerState();

                // Update cover
                updateCover();
            }

            async function randomizeColors() {
                // Get all color values
                const colorButtons = Array.from(document.querySelectorAll('.color-button'));
                const colorValues = colorButtons.map(btn => btn.dataset.color);

                // Random background color
                let bgColor = colorValues[Math.floor(Math.random() * colorValues.length)];

                // Random pattern color (must not match bgColor)
                let patternColor;
                do {
                    patternColor = colorValues[Math.floor(Math.random() * colorValues.length)];
                } while (patternColor === bgColor && colorValues.length > 1);

                currentBgColor = bgColor;
                currentPatternColor = patternColor;

                // Update color picker UI
                updateColorPickerState();

                // Update cover
                updateCover();
            }

            // Call randomizeCover on page load
            randomizeCover();

            // Keep the randomize links working
            document.querySelector('.randomize-link').addEventListener('click', function(e) {
                e.preventDefault();
                randomizeCover();
            });

            document.getElementById('randomizeColorsLink').addEventListener('click', function(e) {
                e.preventDefault();
                randomizeColors();
            });

            function updatePattern() {
                const scale = parseFloat(document.getElementById('patternScale').value);
                document.getElementById('sliderValueLabel').textContent = scale.toFixed(1) + '×';
                
                // Track pattern scale change
                gtag('event', 'pattern_scale_change', {
                    'event_category': 'interaction',
                    'event_label': 'Pattern Scale',
                    'value': scale
                });
                
                drawPattern();
            }
        });
    </script>
</body>
</html>