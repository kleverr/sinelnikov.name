<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HBS Cover Generator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            margin: 0;
            min-height: 100vh;
            background-color: #f0f0f0;
        }

        .container {
            display: flex;
            flex-direction: row;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 14px;
            min-width: 240px;
            padding: 14px 12px 14px 12px;
            background-color: white;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            overflow-y: auto;
            box-sizing: border-box;
            z-index: 1;
        }

        .canvas-area {
            flex: 1 1 0;
            min-width: 0;
            display: flex;
            flex-direction: column;
            overflow: auto;
            height: 100vh;
            box-sizing: border-box;
            position: relative;
            padding: 0;
        }

        .canvas-area-inner {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 0 0 auto;
            padding-top: 50px;
            width: 100%;
            min-width: 0;
            min-height: 0;
            margin: 0;
        }

        .canvas-container {
            position: relative;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            border-radius: 4px;
            min-width: 0;
            margin-bottom: 24px;
            max-width: 100%;
            box-sizing: border-box;
        }

        #coverCanvas {
            display: block;
        }

        .section {
            margin-bottom: 10px;
        }

        .title {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
        }

        .title img {
            height: 1.56em;
            width: auto;
        }

        label {
            margin-bottom: 8px;
            font-size: 0.9em;
            font-weight: bold;
            color: #333;
            display: block;
        }

        .color-mode-toggle, .pattern-group-tabs {
            display: flex;
            gap: 0;
            margin-bottom: 8px;
            padding: 0;
            background: #e9e9e9;
            border-radius: 8px;
            border: 1px solid #ccc;
            overflow: hidden;
        }

        .color-mode-button, .pattern-group-button {
            flex: 1;
            padding: 8px 12px;
            background: #e9e9e9;
            border: none;
            border-right: 1px solid #ccc;
            cursor: pointer;
            font-size: 0.95em;
            color: #666;
            transition: background 0.15s, color 0.15s;
            position: relative;
            font-weight: 500;
        }
        .color-mode-button:last-child, .pattern-group-button:last-child {
            border-right: none;
        }
        .color-mode-button.selected, .pattern-group-button.selected {
            background: #fff;
            color: #222;
            font-weight: 700;
        }
        .color-mode-button:not(.selected):hover, .pattern-group-button:not(.selected):hover {
            background: #e0e0e0;
            color: #222;
        }
        .color-mode-button:first-child, .pattern-group-button:first-child {
            border-top-left-radius: 8px;
            border-bottom-left-radius: 8px;
        }
        .color-mode-button:last-child, .pattern-group-button:last-child {
            border-top-right-radius: 8px;
            border-bottom-right-radius: 8px;
        }

        .color-picker {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 2px;
            width: 100%;
            background-color: white;
            padding: 2px;
            border-radius: 6px;
        }

        .color-button {
            width: 100%;
            height: 20px;
            border: 1px solid transparent;
            cursor: pointer;
            transition: all 0.15s;
            position: relative;
            padding: 0;
            box-sizing: border-box;
            border-radius: 0;
        }

        .color-button:first-child {
            border-top-left-radius: 0;
        }

        .color-button:nth-child(4) {
            border-top-right-radius: 0;
        }

        .color-button:nth-last-child(4) {
            border-bottom-left-radius: 0;
        }

        .color-button:last-child {
            border-bottom-right-radius: 0;
        }

        .color-button.selected {
            outline: 2px solid #000;
            border: 2px solid white;
        }

        .color-button.pattern-selected {
            outline: 2px solid #000;
            border: 2px solid white;
        }

        .color-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 4px 8px;
            background: rgba(0,0,0,0.8);
            color: white;
            border-radius: 4px;
            font-size: 0.8em;
            white-space: nowrap;
            display: none;
            pointer-events: none;
            z-index: 1000;
        }

        .color-button:hover .color-tooltip {
            display: block;
        }

        /* Hide color tabs */
        .color-tabs {
            display: none;
        }
        
        .color-tab {
            display: none;
        }
        
        .color-group {
            display: none;
        }

        /* Color definitions */
        .color-harvard-crimson { background-color: #A41034; }
        .color-red-2 { background-color: #E80538; }
        .color-red-3 { background-color: #ED5541; }
        .color-red-4 { background-color: #E0B2A7; }
        
        .color-orange-1 { background-color: #AE6429; }
        .color-orange-2 { background-color: #E87D1E; }
        .color-orange-3 { background-color: #EA9B20; }
        .color-orange-4 { background-color: #F7C76B; }
        
        .color-yellow-1 { background-color: #C29D00; }
        .color-yellow-2 { background-color: #EBCD00; }
        .color-yellow-3 { background-color: #F3E44D; }
        .color-yellow-4 { background-color: #F4EF6B; }
        
        .color-green-1 { background-color: #026833; }
        .color-green-2 { background-color: #52A52E; }
        .color-green-3 { background-color: #9EC44D; }
        .color-green-4 { background-color: #B3D56A; }
        
        .color-teal-1 { background-color: #006085; }
        .color-teal-2 { background-color: #00979D; }
        .color-teal-3 { background-color: #56BAB3; }
        .color-teal-4 { background-color: #9BD6C4; }
        
        .color-blue-1 { background-color: #3B2883; }
        .color-blue-2 { background-color: #6578B4; }
        .color-blue-3 { background-color: #7FA4D1; }
        .color-blue-4 { background-color: #AAC8EB; }
        
        .color-purple-1 { background-color: #57116A; }
        .color-purple-2 { background-color: #80408D; }
        .color-purple-3 { background-color: #9B7FAF; }
        .color-purple-4 { background-color: #C6B2D1; }
        
        .color-magenta-1 { background-color: #78244C; }
        .color-magenta-2 { background-color: #C9006B; }
        .color-magenta-3 { background-color: #D86199; }
        .color-magenta-4 { background-color: #E599BA; }
        
        .color-black { background-color: #000000; }
        .color-gray-2 { background-color: #68666F; }
        .color-gray-3 { background-color: #A3A0A2; }
        .color-gray-4 { background-color: #D5D0CA; }

        .pattern-picker {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            width: 100%;
            background-color: white;
            padding: 10px;
            border-radius: 6px;
            margin-top: 0.5em;
            box-sizing: border-box;
            justify-items: center;
        }

        .pattern-button {
            width: 100%;
            max-width: 110px;
            aspect-ratio: 1/1;
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            padding: 0;
        }

        .pattern-preview-img {
            width: 80%;
            height: 80%;
            object-fit: cover;
            display: block;
        }

        .pattern-button:hover {
            background: #ececec;
            transform: scale(1.08);
            box-shadow: 0 2px 8px rgba(0,0,0,0.10);
            z-index: 2;
        }

        .pattern-button.selected {
            background: #f8f8f8;
            border: 2px solid #666;
        }

        /* Remove unused styles */
        .pattern-preview,
        .pattern-name,
        .section-header,
        .section-content,
        .collapse-icon {
            display: none;
        }

        .size-picker {
            display: block;
            margin-top: 4px;
            width: 100%;
        }

        .size-select {
            width: 100%;
            padding: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background: #f8f8f8;
            font-size: 0.95em;
            color: #333;
            cursor: pointer;
            transition: all 0.2s;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23333%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 10px;
            padding-right: 30px;
        }

        .size-select:hover {
            background-color: #f0f0f0;
            border-color: #d0d0d0;
        }

        .size-select:focus {
            outline: none;
            border-color: #007AFF;
            box-shadow: 0 0 0 2px rgba(0,122,255,0.2);
        }

        .scale-control {
            margin-top: 4px;
            position: relative;
        }

        .scale-control .scale-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .scale-control label {
            margin: 0;
        }

        .scale-value {
            font-size: 0.9em;
            color: #666;
            font-weight: 500;
        }

        .scale-control input[type="range"] {
            width: 100%;
            margin: 0;
            -webkit-appearance: none;
            background: transparent;
        }

        .scale-control input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #f0f0f0;
            border: none;
            border-radius: 2px;
            cursor: pointer;
        }

        .scale-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            border: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #666666;
            margin-top: -7px;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .scale-control input[type="range"]::-moz-range-track {
            width: 100%;
            height: 4px;
            background: #f0f0f0;
            border: none;
            border-radius: 2px;
            cursor: pointer;
        }

        .scale-control input[type="range"]::-moz-range-thumb {
            border: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #666666;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .scale-control .scale-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 0.85em;
            color: #666;
        }

        #saveBtn {
            display: block;
            margin: 32px auto 0 auto;
            padding: 14px 36px;
            background: #2766b6;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 20px;
        }

        #saveBtn:hover {
            background: #1d4e8c;
        }

        .group-title {
            font-size: 1.1em;
            font-weight: 500;
            color: #666;
            margin-top: 30px;
            margin-bottom: 15px;
            padding-left: 5px;
            border-left: 3px solid #007bff;
        }

        .section-header {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            cursor: pointer;
            user-select: none;
        }

        .section-header .collapse-icon {
            margin-left: auto;
            transition: transform 0.2s;
            font-size: 0.8em;
            color: #666;
        }

        .section-header.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .section-content {
            display: block;
            transition: all 0.2s;
            overflow: hidden;
            max-height: 1000px;
        }

        .section-content.collapsed {
            max-height: 0;
            margin: 0;
            padding: 0;
        }

        .copyright {
            width: 100%;
            text-align: center;
            font-size: 0.85em;
            color: #666;
            padding: 0;
            padding-bottom: 14px;
            margin: 0;
            pointer-events: none;
            margin-top: auto;
        }

        .copyright-left {
            width: auto;
            font-size: 0.85em;
            color: #666;
            padding: 0;
            text-align: left;
            margin-top: auto;
        }

        .copyright-left a {
            color: #666;
            text-decoration: none;
            border-bottom: 1px solid rgba(102, 102, 102, 0.3);
            transition: border-color 0.2s;
        }

        .copyright-left a:hover {
            color: #666;
            border-bottom-color: rgba(102, 102, 102, 0.6);
            text-decoration: none;
        }

        .copyright a {
            color: #666;
            text-decoration: none;
            border-bottom: 1px solid rgba(102, 102, 102, 0.3);
            transition: border-color 0.2s;
            pointer-events: auto;
        }

        .copyright a:hover {
            color: #666;
            border-bottom-color: rgba(102, 102, 102, 0.6);
            text-decoration: none;
        }

        .pattern-group-tabs {
            display: flex;
            flex-direction: column;
            gap: 0;
            margin-bottom: 12px;
            background: #e9e9e9;
            border-radius: 8px;
            border: 1px solid #ccc;
            overflow: hidden;
            width: 100%;
        }

        .pattern-group-button {
            width: 100%;
            padding: 10px 12px;
            background: #e9e9e9;
            border: none;
            border-bottom: 1px solid #ccc;
            cursor: pointer;
            transition: background 0.15s, color 0.15s;
            font-size: 0.95em;
            color: #666;
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-weight: 500;
        }

        .pattern-group-button:last-child {
            border-bottom: none;
        }

        .pattern-group-button.selected {
            background: #fff;
            color: #222;
            font-weight: 700;
        }

        .pattern-group-button:not(.selected):hover {
            background: #e0e0e0;
            color: #222;
        }

        .pattern-group-button:first-child {
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
        }

        .pattern-group-button:last-child {
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
        }

        .color-button:hover {
            z-index: 2;
            transform: scale(1.18);
            box-shadow: 0 2px 8px rgba(0,0,0,0.10);
        }

        /* Remove the pseudo-element */
        .scale-control::after {
            display: none;
        }

        .randomize-link-container {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 18px;
        }
        .randomize-link {
            background: none;
            border: none;
            color: #666;
            font-size: 1em;
            font-weight: 500;
            text-decoration: underline;
            text-decoration-color: rgba(102,102,102,0.25);
            text-underline-offset: 2px;
            padding: 0;
            transition: color 0.15s, text-decoration-color 0.15s;
            display: inline-block;
            cursor: pointer;
        }
        .randomize-link:hover {
            color: #333;
            text-decoration: underline;
            text-decoration-color: rgba(102,102,102,0.45);
        }
        .randomize-link-separator {
            color: #666;
            font-size: 1em;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <div class="title">
                <img src="/cover-generator/images/hbs-logo.png" alt="Harvard Business School Logo">
                HBS Cover Generator
            </div>
            <div class="section">
                <label>Canvas Size</label>
                <div class="size-picker">
                    <select class="size-select" id="sizeSelect">
                        <option value="733x307" selected>Blog Cover (733×307 px)</option>
                        <option value="500x500">Square (500×500 px)</option>
                        <option value="1584x396">LinkedIn Cover (1584×396 px)</option>
                        <option value="custom">Custom...</option>
                    </select>
                </div>
            </div>

            <div class="section">
                <label>Color</label>
                <div class="color-mode-toggle">
                    <button class="color-mode-button selected" data-mode="background">Background</button>
                    <button class="color-mode-button" data-mode="pattern">Pattern</button>
                </div>
                <div class="color-picker" id="colorPicker">
                    <!-- Reds -->
                    <div class="color-button color-harvard-crimson selected" data-color="#A41034">
                        <div class="color-tooltip">Harvard Crimson</div>
                    </div>
                    <div class="color-button color-red-2" data-color="#E80538">
                        <div class="color-tooltip">Red 2</div>
                    </div>
                    <div class="color-button color-red-3" data-color="#ED5541">
                        <div class="color-tooltip">Red 3</div>
                    </div>
                    <div class="color-button color-red-4 pattern-selected" data-color="#E0B2A7">
                        <div class="color-tooltip">Red 4</div>
                    </div>
                    
                    <!-- Oranges -->
                    <div class="color-button color-orange-1" data-color="#AE6429">
                        <div class="color-tooltip">Orange 1</div>
                    </div>
                    <div class="color-button color-orange-2" data-color="#E87D1E">
                        <div class="color-tooltip">Orange 2</div>
                    </div>
                    <div class="color-button color-orange-3" data-color="#EA9B20">
                        <div class="color-tooltip">Orange 3</div>
                    </div>
                    <div class="color-button color-orange-4" data-color="#F7C76B">
                        <div class="color-tooltip">Orange 4</div>
                    </div>
                    
                    <!-- Yellows -->
                    <div class="color-button color-yellow-1" data-color="#C29D00">
                        <div class="color-tooltip">Yellow 1</div>
                    </div>
                    <div class="color-button color-yellow-2" data-color="#EBCD00">
                        <div class="color-tooltip">Yellow 2</div>
                    </div>
                    <div class="color-button color-yellow-3" data-color="#F3E44D">
                        <div class="color-tooltip">Yellow 3</div>
                    </div>
                    <div class="color-button color-yellow-4" data-color="#F4EF6B">
                        <div class="color-tooltip">Yellow 4</div>
                    </div>
                    
                    <!-- Greens -->
                    <div class="color-button color-green-1" data-color="#026833">
                        <div class="color-tooltip">Green 1</div>
                    </div>
                    <div class="color-button color-green-2" data-color="#52A52E">
                        <div class="color-tooltip">Green 2</div>
                    </div>
                    <div class="color-button color-green-3" data-color="#9EC44D">
                        <div class="color-tooltip">Green 3</div>
                    </div>
                    <div class="color-button color-green-4" data-color="#B3D56A">
                        <div class="color-tooltip">Green 4</div>
                    </div>
                    
                    <!-- Teals -->
                    <div class="color-button color-teal-1" data-color="#006085">
                        <div class="color-tooltip">Teal 1</div>
                    </div>
                    <div class="color-button color-teal-2" data-color="#00979D">
                        <div class="color-tooltip">Teal 2</div>
                    </div>
                    <div class="color-button color-teal-3" data-color="#56BAB3">
                        <div class="color-tooltip">Teal 3</div>
                    </div>
                    <div class="color-button color-teal-4" data-color="#9BD6C4">
                        <div class="color-tooltip">Teal 4</div>
                    </div>
                    
                    <!-- Blues -->
                    <div class="color-button color-blue-1" data-color="#3B2883">
                        <div class="color-tooltip">Blue 1</div>
                    </div>
                    <div class="color-button color-blue-2" data-color="#6578B4">
                        <div class="color-tooltip">Blue 2</div>
                    </div>
                    <div class="color-button color-blue-3" data-color="#7FA4D1">
                        <div class="color-tooltip">Blue 3</div>
                    </div>
                    <div class="color-button color-blue-4" data-color="#AAC8EB">
                        <div class="color-tooltip">Blue 4</div>
                    </div>
                    
                    <!-- Purples -->
                    <div class="color-button color-purple-1" data-color="#57116A">
                        <div class="color-tooltip">Purple 1</div>
                    </div>
                    <div class="color-button color-purple-2" data-color="#80408D">
                        <div class="color-tooltip">Purple 2</div>
                    </div>
                    <div class="color-button color-purple-3" data-color="#9B7FAF">
                        <div class="color-tooltip">Purple 3</div>
                    </div>
                    <div class="color-button color-purple-4" data-color="#C6B2D1">
                        <div class="color-tooltip">Purple 4</div>
                    </div>
                    
                    <!-- Magentas -->
                    <div class="color-button color-magenta-1" data-color="#78244C">
                        <div class="color-tooltip">Magenta 1</div>
                    </div>
                    <div class="color-button color-magenta-2" data-color="#C9006B">
                        <div class="color-tooltip">Magenta 2</div>
                    </div>
                    <div class="color-button color-magenta-3" data-color="#D86199">
                        <div class="color-tooltip">Magenta 3</div>
                    </div>
                    <div class="color-button color-magenta-4" data-color="#E599BA">
                        <div class="color-tooltip">Magenta 4</div>
                    </div>
                    
                    <!-- Grays -->
                    <div class="color-button color-black" data-color="#000000">
                        <div class="color-tooltip">Black</div>
                    </div>
                    <div class="color-button color-gray-2" data-color="#68666F">
                        <div class="color-tooltip">Gray 2</div>
                    </div>
                    <div class="color-button color-gray-3" data-color="#A3A0A2">
                        <div class="color-tooltip">Gray 3</div>
                    </div>
                    <div class="color-button color-gray-4" data-color="#D5D0CA">
                        <div class="color-tooltip">Gray 4</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <label>Pattern</label>
                <div class="pattern-picker" id="patternPicker">
                    <!-- Pattern buttons will be generated by JS -->
                </div>
            </div>

            <div class="section">
                <div class="scale-control">
                    <div class="scale-header">
                        <label for="patternScale">Pattern Scale</label>
                        <span class="scale-value"><span id="scaleValue">1.00</span>×</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="patternScale" min="0.2" max="5" step="0.1" value="1">
                    </div>
                    <div class="scale-labels">
                        <span>0.2×</span>
                        <span>5×</span>
                    </div>
                </div>
            </div>
            <div class="copyright-left">
                © <a href="https://sinelnikov.name/" target="_blank">Ilya Sinelnikov</a>, 2025
            </div>
        </div>
        <div class="canvas-area">
            <div class="canvas-area-inner">
                <div class="randomize-link-container">
                    <a href="#" class="randomize-link">Randomize all</a>
                    <span class="randomize-link-separator">·</span>
                    <a href="#" class="randomize-link" id="randomizeColorsLink">Only colors</a>
                </div>
                <div class="canvas-container">
                    <svg id="coverCanvas" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 500">
                        <!-- Background rectangle -->
                        <rect id="background" width="100%" height="100%" />
                        
                        <!-- Pattern definition -->
                        <defs>
                            <pattern id="architecturePattern" 
                                    patternUnits="userSpaceOnUse"
                                    patternTransform="translate(0,0)">
                                <g id="patternGroup" transform-origin="center">
                                    <image id="patternImage" 
                                           preserveAspectRatio="xMidYMid meet" />
                                </g>
                            </pattern>
                        </defs>
                        
                        <!-- Pattern overlay -->
                        <rect id="patternOverlay" width="100%" height="100%" fill="url(#architecturePattern)" y="0" />
                    </svg>
                </div>
                <button id="saveBtn">Save Image</button>
            </div>
            <div class="copyright">
                Patterns and color palette adapted from <a href="https://identity.hbs.edu/graphics/" target="_blank">Harvard Business School identity guidelines</a>
            </div>
        </div>
    </div>

    <div id="customSizeModal" style="display:none; position:fixed; z-index:10000; left:0; top:0; width:100vw; height:100vh; background:rgba(0,0,0,0.25); align-items:center; justify-content:center;">
        <div style="background:white; border-radius:8px; box-shadow:0 2px 16px rgba(0,0,0,0.15); padding:32px 24px; min-width:320px; max-width:90vw;">
            <h3 style="margin-top:0;">Custom Canvas Size</h3>
            <div style="margin-bottom:16px;">
                <label for="customWidth">Width (px):</label>
                <input id="customWidth" type="number" min="1" max="5000" value="800" style="width:80px; margin-left:8px;">
            </div>
            <div style="margin-bottom:24px;">
                <label for="customHeight">Height (px):</label>
                <input id="customHeight" type="number" min="1" max="5000" value="400" style="width:80px; margin-left:8px;">
            </div>
            <button id="customSizeOk" style="background:#007AFF; color:white; border:none; border-radius:4px; padding:8px 18px; font-weight:500; margin-right:8px;">OK</button>
            <button id="customSizeCancel" style="background:#eee; color:#333; border:none; border-radius:4px; padding:8px 18px;">Cancel</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const CANVAS_SIZE = 500;
            let currentBgColor;
            let currentPatternColor;
            let currentPatternGroup;
            let currentPattern;
            let canvasWidth = 733;
            let canvasHeight = 307;
            let currentColorMode = 'background';

            // Pattern group to folder and file naming mapping
            const PATTERN_GROUP_CONFIG = {
                'Architecture': {
                    folder: 'HBS-Architecture-Patterns',
                    file: n => `HBS_pattern_architecture_${n}.svg`,
                    name: n => `Architecture ${n}`
                },
                'Fences': {
                    folder: 'HBS-Fences-Patterns',
                    file: n => `HBS_Fences_Patterns_${n}.svg`,
                    name: n => `Fences ${n}`
                },
                'Geometric': {
                    folder: 'HBS-Geometric-Patterns',
                    file: n => `HBS_pattern_geometric_${n}.svg`,
                    name: n => `Geometric ${n}`
                },
                'Shields': {
                    folder: 'HBS-Shields-Patterns',
                    file: n => `HBS_pattern_shield_${n}.svg`,
                    name: n => `Shields ${n}`
                }
            };

            // Build a flat list of all patterns
            const ALL_PATTERNS = [];
            for (const group of Object.keys(PATTERN_GROUP_CONFIG)) {
                for (let i = 1; i <= 4; i++) {
                    ALL_PATTERNS.push({
                        group,
                        number: i,
                        name: PATTERN_GROUP_CONFIG[group].name(i),
                        folder: PATTERN_GROUP_CONFIG[group].folder,
                        file: PATTERN_GROUP_CONFIG[group].file(i)
                    });
                }
            }

            // Render all pattern buttons
            const patternPicker = document.getElementById('patternPicker');
            patternPicker.innerHTML = '';
            ALL_PATTERNS.forEach((pattern, idx) => {
                const btn = document.createElement('button');
                btn.className = 'pattern-button';
                btn.dataset.group = pattern.group;
                btn.dataset.pattern = pattern.number;
                btn.style.gridColumn = (idx % 2) + 1;
                // Tooltip
                const tooltip = document.createElement('span');
                tooltip.className = 'color-tooltip';
                tooltip.textContent = pattern.name;
                btn.appendChild(tooltip);
                // Image
                const img = document.createElement('img');
                img.className = 'pattern-preview-img';
                img.alt = pattern.name;
                // Load SVG preview as base64
                fetch(`patterns/${pattern.folder}/${pattern.file}`)
                    .then(r => r.text())
                    .then(svgText => {
                        // Zoom in 5x by adjusting the viewBox
                        const viewBoxMatch = svgText.match(/viewBox="([\d\.\s]+)"/);
                        if (viewBoxMatch) {
                            const [, viewBox] = viewBoxMatch;
                            const [x, y, w, h] = viewBox.split(/\s+/).map(Number);
                            const zoom = 5;
                            const newW = w / zoom;
                            const newH = h / zoom;
                            const newX = x + (w - newW) / 2;
                            const newY = y + (h - newH) / 2;
                            svgText = svgText.replace(/viewBox="[^"]+"/, `viewBox="${newX} ${newY} ${newW} ${newH}"`);
                        }
                        const svgBase64 = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgText)));
                        img.src = svgBase64;
                    })
                    .catch(() => { img.src = ''; });
                btn.appendChild(img);
                // Hover for tooltip
                btn.onmouseenter = () => { tooltip.style.display = 'block'; };
                btn.onmouseleave = () => { tooltip.style.display = 'none'; };
                // Click to select
                btn.onclick = () => {
                    document.querySelectorAll('.pattern-button').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    currentPatternGroup = pattern.group;
                    currentPattern = pattern.number;
                    updateCover();
                };
                patternPicker.appendChild(btn);
            });
            // Select the first pattern by default
            if (ALL_PATTERNS.length > 0) {
                patternPicker.firstChild.classList.add('selected');
                currentPatternGroup = ALL_PATTERNS[0].group;
                currentPattern = ALL_PATTERNS[0].number;
                if (!currentBgColor) currentBgColor = "#A41034";
                if (!currentPatternColor) currentPatternColor = "#E0B2A7";
            }

            // DOM elements must be defined before calling update functions
            const pattern = document.getElementById('architecturePattern');
            const patternImage = document.getElementById('patternImage');
            const background = document.getElementById('background');
            const patternScaleInput = document.getElementById('patternScale');
            const scaleValueSpan = document.getElementById('scaleValue');
            const coverCanvas = document.getElementById('coverCanvas');
            const canvasContainer = document.querySelector('.canvas-container');

            // Store the current pattern's viewBox dimensions
            let currentPatternViewBox = { svgWidth: 2246.51, svgHeight: 1532.98 };

            // Initialize all controls
            setupColorModeToggle();
            setupColorPicker('colorPicker');
            setupSizePicker();

            // Initial update (now safe)
            updateColorPickerState();
            updateCanvasSize();
            updateCover();

            function updateCanvasSize() {
                // Update SVG viewBox
                coverCanvas.setAttribute('viewBox', `0 0 ${canvasWidth} ${canvasHeight}`);
                
                // Set maximum dimensions for display
                const maxDisplayWidth = 1200; // Increased from 800 to accommodate LinkedIn size
                const maxDisplayHeight = 600;
                
                // Calculate scale to fit within maximum dimensions while maintaining aspect ratio
                const widthScale = maxDisplayWidth / canvasWidth;
                const heightScale = maxDisplayHeight / canvasHeight;
                const scale = Math.min(widthScale, heightScale, 1); // Added 1 as maximum to prevent upscaling
                
                // Calculate final display dimensions
                const displayWidth = canvasWidth * scale;
                const displayHeight = canvasHeight * scale;
                
                // Update container size
                canvasContainer.style.width = `${displayWidth}px`;
                canvasContainer.style.height = `${displayHeight}px`;
                
                // Update background rectangle
                background.setAttribute('width', canvasWidth);
                background.setAttribute('height', canvasHeight);
                
                // Update pattern overlay
                document.getElementById('patternOverlay').setAttribute('width', canvasWidth);
                document.getElementById('patternOverlay').setAttribute('height', canvasHeight);
            }

            async function updateCover() {
                if (!currentPatternGroup || !currentPattern || !PATTERN_GROUP_CONFIG[currentPatternGroup]) {
                    console.warn('updateCover called with invalid group or pattern:', currentPatternGroup, currentPattern);
                    return;
                }
                background.setAttribute('fill', currentBgColor);
                try {
                    // Map group to folder and file
                    const config = PATTERN_GROUP_CONFIG[currentPatternGroup];
                    const folder = config.folder;
                    const file = config.file(currentPattern);
                    const response = await fetch(`patterns/${folder}/${file}`);
                    if (!response.ok) {
                        throw new Error(`Pattern file not found: patterns/${folder}/${file}`);
                    }
                    const svgText = await response.text();
                    // Extract viewBox dimensions from SVG
                    const viewBoxMatch = svgText.match(/viewBox="([\d\.\s]+)"/);
                    if (viewBoxMatch) {
                        const [, viewBox] = viewBoxMatch;
                        const [x, y, w, h] = viewBox.split(/\s+/).map(Number);
                        currentPatternViewBox = { svgWidth: w, svgHeight: h };
                    } else {
                        currentPatternViewBox = { svgWidth: 2246.51, svgHeight: 1532.98 };
                    }
                    // Create a temporary DOM element to parse and modify the SVG
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
                    // Add fill and stroke attributes to all path elements that don't have them
                    svgDoc.querySelectorAll('path').forEach(path => {
                        if (!path.hasAttribute('fill')) {
                            path.setAttribute('fill', 'none');
                        }
                        if (!path.hasAttribute('stroke')) {
                            path.setAttribute('stroke', currentPatternColor);
                        }
                    });
                    // Convert back to string
                    const serializer = new XMLSerializer();
                    let coloredSvg = serializer.serializeToString(svgDoc);
                    // Replace any remaining color attributes
                    coloredSvg = coloredSvg
                        .replace(/stroke: ?#[^;]*/g, `stroke: ${currentPatternColor}`)
                        .replace(/stroke="[^"]*"/g, `stroke="${currentPatternColor}"`)
                        .replace(/fill: ?#[^;]*/g, `fill: ${currentPatternColor}`)
                        .replace(/fill="[^"]*"/g, `fill="${currentPatternColor}"`);
                    const blob = new Blob([coloredSvg], { type: 'image/svg+xml' });
                    const url = URL.createObjectURL(blob);
                    // Update the pattern image
                    patternImage.setAttribute('href', url);
                    // Clean up the old URL if it exists
                    const oldUrl = patternImage.dataset.url;
                    if (oldUrl) {
                        URL.revokeObjectURL(oldUrl);
                    }
                    patternImage.dataset.url = url;
                    // Update pattern dimensions after loading new SVG
                    updatePatternDimensions();
                } catch (error) {
                    console.error('Error loading pattern:', error, 'Group:', currentPatternGroup, 'Pattern:', currentPattern);
                    alert('Error loading pattern. Please make sure the server is running and the pattern exists.\n' + error);
                }
            }

            function updatePatternDimensions() {
                const scale = parseFloat(patternScaleInput.value) || 1;
                // Use the dynamically extracted viewBox dimensions
                const { svgWidth, svgHeight } = currentPatternViewBox;
                const svgAspectRatio = svgWidth / svgHeight;
                // Calculate base dimensions to match canvas height at scale 1.0
                const baseHeight = canvasHeight;
                const baseWidth = baseHeight * svgAspectRatio;
                // Calculate scaled dimensions
                const scaledWidth = baseWidth * scale;
                const scaledHeight = baseHeight * scale;
                // Calculate offset to keep pattern centered
                const offsetX = (canvasWidth - scaledWidth) / 2;
                const offsetY = (canvasHeight - scaledHeight) / 2;
                // Update pattern attributes
                pattern.setAttribute('width', scaledWidth);
                pattern.setAttribute('height', scaledHeight);
                pattern.setAttribute('patternTransform', `translate(${offsetX},${offsetY})`);
                // Update image dimensions
                patternImage.setAttribute('width', scaledWidth);
                patternImage.setAttribute('height', scaledHeight);
            }

            // Restore slider event listener for dynamic scaling
            patternScaleInput.addEventListener('input', () => {
                const scale = parseFloat(patternScaleInput.value);
                updatePatternDimensions();
                scaleValueSpan.textContent = scale.toFixed(2);
            });

            function setupSizePicker() {
                const sizeSelect = document.getElementById('sizeSelect');
                const customSizeModal = document.getElementById('customSizeModal');
                const customWidthInput = document.getElementById('customWidth');
                const customHeightInput = document.getElementById('customHeight');
                const customOkBtn = document.getElementById('customSizeOk');
                const customCancelBtn = document.getElementById('customSizeCancel');

                sizeSelect.addEventListener('change', () => {
                    const [width, height] = sizeSelect.value.split('x').map(Number);
                    if (sizeSelect.value === 'custom') {
                        // Show modal
                        customSizeModal.style.display = 'flex';
                        // Set defaults to current size
                        customWidthInput.value = canvasWidth;
                        customHeightInput.value = canvasHeight;
                    } else {
                        canvasWidth = width;
                        canvasHeight = height;
                        updateCanvasSize();
                        updatePatternDimensions();
                    }
                });
                // Modal OK
                customOkBtn.addEventListener('click', () => {
                    const w = parseInt(customWidthInput.value, 10);
                    const h = parseInt(customHeightInput.value, 10);
                    if (w > 0 && h > 0) {
                        canvasWidth = w;
                        canvasHeight = h;
                        updateCanvasSize();
                        updatePatternDimensions();
                        // Set dropdown to custom
                        sizeSelect.value = 'custom';
                        customSizeModal.style.display = 'none';
                    }
                });
                // Modal Cancel
                customCancelBtn.addEventListener('click', () => {
                    customSizeModal.style.display = 'none';
                    // Reset dropdown to previous value
                    sizeSelect.selectedIndex = 0;
                });
                // Hide modal on outside click
                customSizeModal.addEventListener('click', (e) => {
                    if (e.target === customSizeModal) {
                        customSizeModal.style.display = 'none';
                        sizeSelect.selectedIndex = 0;
                    }
                });
            }

            function setupColorModeToggle() {
                const toggleButtons = document.querySelectorAll('.color-mode-button');
                const colorPicker = document.getElementById('colorPicker');
                
                // Set initial state
                updateColorPickerState();

                toggleButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        toggleButtons.forEach(b => b.classList.remove('selected'));
                        button.classList.add('selected');
                        currentColorMode = button.dataset.mode;
                        updateColorPickerState();
                    });
                });
            }

            function updateColorPickerState() {
                const colorPicker = document.getElementById('colorPicker');
                const buttons = colorPicker.querySelectorAll('.color-button');
                
                // Clear all selections first
                buttons.forEach(button => {
                    button.classList.remove('selected', 'pattern-selected');
                });
                
                // Add selection based on current colors
                buttons.forEach(button => {
                    if (currentColorMode === 'background' && button.dataset.color === currentBgColor) {
                        button.classList.add('selected');
                    } else if (currentColorMode === 'pattern' && button.dataset.color === currentPatternColor) {
                        button.classList.add('pattern-selected');
                    }
                });
            }

            function setupColorPicker(pickerId) {
                const picker = document.getElementById(pickerId);
                const buttons = picker.querySelectorAll('.color-button');

                buttons.forEach(button => {
                    button.addEventListener('click', () => {
                        const color = button.dataset.color;
                        if (currentColorMode === 'background') {
                            currentBgColor = color;
                        } else {
                            currentPatternColor = color;
                        }
                        updateColorPickerState();
                        updateCover();
                    });
                });
            }

            async function convertImageToBase64(url, color) {
                // Map group to folder and file
                const config = PATTERN_GROUP_CONFIG[currentPatternGroup];
                const folder = config.folder;
                const file = config.file(currentPattern);
                const response = await fetch(`patterns/${folder}/${file}`);
                const svgText = await response.text();
                
                // Create a temporary DOM element to parse and modify the SVG
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
                
                // Add fill and stroke attributes to all path elements
                svgDoc.querySelectorAll('path').forEach(path => {
                    if (!path.hasAttribute('fill')) {
                        path.setAttribute('fill', 'none');
                    }
                    if (!path.hasAttribute('stroke')) {
                        path.setAttribute('stroke', color);
                    }
                });
                
                // Convert back to string and replace any remaining color attributes
                const serializer = new XMLSerializer();
                let coloredSvg = serializer.serializeToString(svgDoc);
                
                // Replace any remaining color attributes
                coloredSvg = coloredSvg
                    .replace(/stroke: ?#[^;]*/g, `stroke: ${color}`)
                    .replace(/stroke="[^"]*"/g, `stroke="${color}"`)
                    .replace(/fill: ?#[^;]*/g, `fill: ${color}`)
                    .replace(/fill="[^"]*"/g, `fill="${color}"`);
                
                // Convert to blob and then to base64
                const blob = new Blob([coloredSvg], { type: 'image/svg+xml' });
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            document.getElementById('saveBtn').addEventListener('click', async () => {
                try {
                    // Get the SVG element that's currently rendered
                    const svg = document.getElementById('coverCanvas');
                    
                    // Clone the SVG to preserve the exact state
                    const clonedSvg = svg.cloneNode(true);
                    
                    // Copy computed dimensions and viewBox
                    clonedSvg.setAttribute('width', canvasWidth);
                    clonedSvg.setAttribute('height', canvasHeight);
                    clonedSvg.setAttribute('viewBox', `0 0 ${canvasWidth} ${canvasHeight}`);
                    
                    // Ensure pattern is copied correctly
                    const originalPattern = svg.querySelector('#architecturePattern');
                    const clonedPattern = clonedSvg.querySelector('#architecturePattern');
                    
                    if (originalPattern && clonedPattern) {
                        // Copy all attributes
                        Array.from(originalPattern.attributes).forEach(attr => {
                            clonedPattern.setAttribute(attr.name, attr.value);
                        });
                        
                        // Handle pattern image
                        const originalImage = originalPattern.querySelector('image');
                        const clonedImage = clonedPattern.querySelector('image');
                        if (originalImage && clonedImage) {
                            // Get the current pattern URL
                            const config = PATTERN_GROUP_CONFIG[currentPatternGroup];
                            const folder = config.folder;
                            const file = config.file(currentPattern);
                            const patternUrl = `patterns/${folder}/${file}`;
                            
                            // Convert pattern to base64 with color
                            const base64Pattern = await convertImageToBase64(patternUrl, currentPatternColor);
                            clonedImage.setAttribute('href', base64Pattern);
                            
                            // Copy other attributes
                            Array.from(originalImage.attributes).forEach(attr => {
                                if (attr.name !== 'href') {
                                    clonedImage.setAttribute(attr.name, attr.value);
                                }
                            });
                        }
                    }
                    
                    // Create canvas with the exact dimensions
                    const canvas = document.createElement('canvas');
                    canvas.width = canvasWidth;
                    canvas.height = canvasHeight;
                    const ctx = canvas.getContext('2d');
                    
                    // Convert cloned SVG to data URL
                    const svgData = new XMLSerializer().serializeToString(clonedSvg);
                    const svgBlob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
                    const svgUrl = URL.createObjectURL(svgBlob);
                    
                    // Create a new promise to handle image loading
                    await new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => {
                            // Fill background first
                            ctx.fillStyle = currentBgColor;
                            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                            
                            // Draw the SVG
                            ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
                            
                            // Create and trigger download
                            const link = document.createElement('a');
                            link.download = `cover-${canvasWidth}x${canvasHeight}.png`;
                            link.href = canvas.toDataURL('image/png', 1.0);
                            link.click();
                            
                            // Cleanup
                            URL.revokeObjectURL(svgUrl);
                            resolve();
                        };
                        
                        img.onerror = (error) => {
                            console.error('Error loading SVG:', error);
                            URL.revokeObjectURL(svgUrl);
                            reject(new Error('Failed to load SVG'));
                        };
                        
                        img.src = svgUrl;
                    });
                } catch (error) {
                    console.error('Error saving image:', error);
                    alert('Error generating the image. Please try again.');
                }
            });

            // --- RANDOMIZE LINK FUNCTIONALITY ---
            async function randomizeCover() {
                // 1. Random pattern group
                const patternGroups = Object.keys(PATTERN_GROUP_CONFIG);
                const randomGroup = patternGroups[Math.floor(Math.random() * patternGroups.length)];
                currentPatternGroup = randomGroup;
                // Update pattern group tab UI
                document.querySelectorAll('.pattern-group-button').forEach(btn => {
                    btn.classList.toggle('selected', btn.dataset.group === randomGroup);
                });

                // 2. Random pattern (1-4)
                const randomPattern = (Math.floor(Math.random() * 4) + 1).toString();
                currentPattern = randomPattern;
                // Update pattern button UI
                document.querySelectorAll('.pattern-button').forEach(btn => {
                    btn.classList.toggle('selected', btn.dataset.pattern === randomPattern);
                });

                // 3. Get all color values
                const colorButtons = Array.from(document.querySelectorAll('.color-button'));
                const colorValues = colorButtons.map(btn => btn.dataset.color);

                // 4. Random background color
                let bgColor = colorValues[Math.floor(Math.random() * colorValues.length)];

                // 5. Random pattern color (must not match bgColor)
                let patternColor;
                do {
                    patternColor = colorValues[Math.floor(Math.random() * colorValues.length)];
                } while (patternColor === bgColor && colorValues.length > 1);

                currentBgColor = bgColor;
                currentPatternColor = patternColor;

                // Update color picker UI
                updateColorPickerState();

                // Update cover
                updateCover();
            }

            async function randomizeColors() {
                // Get all color values
                const colorButtons = Array.from(document.querySelectorAll('.color-button'));
                const colorValues = colorButtons.map(btn => btn.dataset.color);

                // Random background color
                let bgColor = colorValues[Math.floor(Math.random() * colorValues.length)];

                // Random pattern color (must not match bgColor)
                let patternColor;
                do {
                    patternColor = colorValues[Math.floor(Math.random() * colorValues.length)];
                } while (patternColor === bgColor && colorValues.length > 1);

                currentBgColor = bgColor;
                currentPatternColor = patternColor;

                // Update color picker UI
                updateColorPickerState();

                // Update cover
                updateCover();
            }

            // Call randomizeCover on page load
            randomizeCover();

            // Keep the randomize links working
            document.querySelector('.randomize-link').addEventListener('click', function(e) {
                e.preventDefault();
                randomizeCover();
            });

            document.getElementById('randomizeColorsLink').addEventListener('click', function(e) {
                e.preventDefault();
                randomizeColors();
            });
        });
    </script>
</body>
</html>